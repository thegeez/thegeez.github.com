<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>thegeez blog</title>
 <link rel="self" href="http://thegeez.github.com/atom.xml" />
 <link href="http://thegeez.github.com/" />
 <updated>2012-04-02T20:37:51Z</updated>
 <id>http://thegeez.github.com/</id>
 <author>
   <name>Gijs Stuurman</name>
 </author>
 <entry>
   <title>Why BrowserChannel?</title>
   <link href="http://thegeez.github.com/2012/04/03/why_browserchannel.html" />
   <updated>2012-04-03T00:00:00Z</updated>
   <id>http://thegeez.github.com/2012/04/03/why_browserchannel.html</id>
   <content type="html">&lt;html&gt;&lt;body&gt;&lt;h1 id="post-title"&gt;Why BrowserChannel?&lt;/h1&gt;
&lt;p&gt;After the release
  of &lt;a href="https://github.com/thegeez/clj-browserchannel-demo"&gt;clj-browserchannel-demo&lt;/a&gt;,
  I have been asked what BrowserChannel is exactly. This post will
  hopefully clarify what BrowserChannel is and why it is a great fit
  for ClojureScript and Clojure web applications.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://closure-library.googlecode.com/svn-history/r144/docs/closure_goog_net_browserchannel.js.html"&gt;BrowserChannel&lt;/a&gt; is a protocol developed by Google. It provides cross-browser compatible, real-time, bi-directional communication
  for various Google web apps, including Google Docs and GMail.&lt;/p&gt;

&lt;p&gt;An important part of this definition is the &lt;b&gt;bi-directional&lt;/b&gt;
  communication. The client can send messages to the server and
  the server can send messages to the client. Canonical examples
  that require these types of communication are chat applications and
  stock/news tickers. In a chat app the client can send
  something to the server and whenever somebody else says something
  this needs to be pushed to all the clients. A stock ticker might not
  need the client to send stuff to the server, but the server needs to
  be able to constantly push messages to the client. This
  bi-directional communication is more elaborate than just AJAX
  request that don't need a page refresh. An example of
  uni-directional client-&amp;gt;server communication is the &lt;a href="http://clojurescriptone.com/"&gt;ClojureScriptOne&lt;/a&gt;
  example application.&lt;/p&gt;

&lt;p&gt;Similar bi-directional communication functionality is provided by
  &lt;a href="http://en.wikipedia.org/wiki/Comet"&gt;Comet&lt;/a&gt; libraries,
  &lt;a href="http://socket.io/"&gt;Socket.io&lt;/a&gt;, &lt;a href="http://sockjs.org"&gt;Sock.js&lt;/a&gt;
  and &lt;a href="http://en.wikipedia.org/wiki/WebSocket"&gt;WebSockets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For ClojureScript and Clojure web apps that need bi-directional
  communication BrowserChannel is a good fit. The client side part of
  BrowserChannel is part of the &lt;a href="https://developers.google.com/closure/library/"&gt;Google Closure Library&lt;/a&gt; and
  ClojureScript leverages the Google Closure compiler and library
  extensively already. In the clj-browserchannel-demo this good fit
  shows by the
  few &lt;a href="https://github.com/thegeez/clj-browserchannel-demo/blob/master/cljs/bc/core.cljs"&gt;lines&lt;/a&gt;
  of ClojureScript that are required. There are no external JavaScript
  dependencies besides the Closure library. The server side portion of
  BrowserChannel has not been open-sourced. clj-browserchannel-demo
  fills this hole with an &lt;a href="https://github.com/thegeez/clj-browserchannel-demo/blob/master/src/net/thegeez/browserchannel.clj"&gt;implementation&lt;/a&gt; in Clojure.&lt;/p&gt;

&lt;h2&gt;WebSockets&lt;/h2&gt;
&lt;p&gt;WebSockets will ultimately replace BrowserChannel completely, as it
  serves the exact same purpose. But WebSockets is under heavy
  development and constant change. Therefore very few clients properly
  support WebSockets. BrowserChannel delivers the functionality right
  now, with support on almost every client imaginable, including
  Internet Explorer 5.5+. I know of only one shop that used WebSockets
  in production and they dropped support for WebSockets after users
  reported problems, mostly behind firewalls.&lt;/p&gt;

&lt;p&gt;BrowserChannel is a pragmatic alternative to WebSockets that works on
many clients today:
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;XHR connections or forever iframes for Internet Explorer&lt;/li&gt;
&lt;li&gt;Both in streaming and non-streaming versions&lt;/li&gt;
&lt;li&gt;Explicit testing for buffering problems on the connection&lt;/li&gt;
&lt;li&gt;Cross domain possible by using XPC&lt;/li&gt;
&lt;li&gt;Work around for connection limits to the same domain&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The cost over WebSockets is the overhead of requiring more requests between the client and server.&lt;/p&gt;

&lt;h2&gt;The punchline&lt;/h2&gt;
&lt;p&gt;Of course the question is if BrowserChannel is production ready: open
firebug, goto gmail.com and look for the GET and POST requests to
  /channel/test?VER=8 and /channel/bind?VER=8:&lt;/p&gt;

&lt;img src="/images/gmail_browserchannel.png" /&gt;
&lt;p&gt;For further information see the &lt;a href="https://github.com/thegeez/clj-browserchannel-demo"&gt;README&lt;/a&gt; of the clj-browserchannel-demo
project on GitHub.&lt;/p&gt;

&lt;/body&gt;&lt;/html&gt;</content>
 </entry><entry>
   <title>Racket Gin Rummy in ClojureScript</title>
   <link href="http://thegeez.github.com/2012/03/20/racket_gin_clojurescript.html" />
   <updated>2012-03-20T00:00:00Z</updated>
   <id>http://thegeez.github.com/2012/03/20/racket_gin_clojurescript.html</id>
   <content type="html">&lt;html&gt;&lt;body&gt;&lt;h1 id="post-title"&gt;Racket Gin Rummy in ClojureScript&lt;/h1&gt;
&lt;p&gt;A ClojureScript implementation of a simple card game. The game can
  be played &lt;a href="http://thegeez-gin.s3-website-eu-west-1.amazonaws.com/"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The Racket programming environment comes with a couple of example
  games written in Scheme. My favorite of these games is Gin
  Rummy. The object of this game is to make a hand of 10 cards,
  consisting of a set of four cards and two sets of three cards. A set
  of cards are cards of the same rank (i.e. three Jacks) or subsequent
  cards of the same suit (i.e. 8,9,10,J of hearts). An ace can be low
  or high. The game has two players with ten cards each. In the middle
  are the deck of cards faced down and a discard pile, with cards face
  up. Players take turns and can choose to pick to top card of the
  discard pile or a face down card from the deck. The chosen card has
  to be exchanged for a card in the players hand, which is placed on
  top of the discard pile. For more information see the
  &lt;a href="http://docs.racket-lang.org/games/ginrummy.html"&gt; Racket documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/thegeez/cljs-gin"&gt;cljs-gin&lt;/a&gt; is an
  implementation of Gin Rummy in ClojureScript. The games runs
  completely in the browser. The Clojure code for the opponent is from
  a program that takes control of the mouse to play the game against
  the original Scheme client. This code worked  without change in
  ClojureScript, but its naive algorithm from the Scheme source has
  been optimized for speed in the browser. The cards are draggable
  div elements, using
  the &lt;a href="http://closure-library.googlecode.com/svn/docs/class_goog_fx_Dragger.html"&gt;Dragger&lt;/a&gt;
  class from the google closure library.&lt;/p&gt;

&lt;p&gt;The game is hosted on Amazon
  S3: &lt;a href="http://thegeez-gin.s3-website-eu-west-1.amazonaws.com/"&gt;Gin
  Rummy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The &lt;a href="http://thegeez-gin.s3-website-eu-west-1.amazonaws.com/index-dev.html"&gt;development
    version&lt;/a&gt; has a view of the table state, including the cards of
  the opponent. This is a consequence of the whole application living
  at the client. However the code is written to support communication
  with a server for a remote opponent in the future.&lt;/p&gt; 

&lt;p&gt;The code is on &lt;a href="https://github.com/thegeez/cljs-gin"&gt;Github&lt;/a&gt;.&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</content>
 </entry><entry>
   <title>Simple static blog with Clojure</title>
   <link href="http://thegeez.github.com/2012/03/15/static_blog_on_github_with_enlive.html" />
   <updated>2012-03-15T00:00:00Z</updated>
   <id>http://thegeez.github.com/2012/03/15/static_blog_on_github_with_enlive.html</id>
   <content type="html">&lt;html&gt;&lt;body&gt;&lt;h1 id="post-title"&gt;Simple static blog with Clojure&lt;/h1&gt;
&lt;p&gt;This inaugural post for this Clojure blog describes how it is
created. This blog is hosted by GitHub Pages and the static pages are
generated by a minimal clone for Jekyll written in Clojure and
using Enlive. The code is by no means a replacement for Jekyll, but
can serve as a starting point for people wanting to do the same.&lt;/p&gt;

&lt;p&gt;The code for the static pages generator is in the &lt;a href="https://github.com/thegeez/clj-static-blog"&gt;clj-static-blog&lt;/a&gt; project.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://pages.github.com"&gt;Github Pages&lt;/a&gt; can host static pages under username.github.com.
Their suggested method to generate static pages is with &lt;a href="http://github.com/mojombo/jekyll/"&gt;Jekyll&lt;/a&gt;. As I
could not get Jekyll to run, I had enough of an excuse to use Clojure
and Enlive for the task.&lt;/p&gt;

&lt;p&gt;
What clj-static-blog does:
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Put each post in a template with a header and footer&lt;/li&gt;
&lt;li&gt;Create an index.html with a list of posts&lt;/li&gt;
&lt;li&gt;Create an atom rss feed whit a list of posts&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It also includes a small webserver to browse the generated pages
locally. GitHub Pages runs Jekyll when changes are pushed to a pages
repository. For this blog the static pages are checked-in,
rather than the sources, because the generator is not run on
GitHub. The Jekyll processing is disabled by the .nojekyll file in
this repo.&lt;/p&gt;

&lt;p&gt;The core of clj-static-blog is the Enlive library. &lt;a href="https://github.com/cgrand/enlive"&gt;Enlive&lt;/a&gt; is a
selector-based (à la CSS) templating library for Clojure, by
  Christophe Grand. The readme of Enlive points to two good
tutorials. Here I just want to highlight to core functionality of
Enlive.&lt;/p&gt;

&lt;p&gt;Enlive does selection and transformations. Using only the
selectors Enlive can be used to scrape websites. With the addition of
transformations Enlive can be used for HTML templating.&lt;/p&gt;

&lt;pre&gt;
&lt;span class="comment-delimiter"&gt;;; &lt;/span&gt;&lt;span class="comment"&gt;html is seq of {:tag :attrs :content}
&lt;/span&gt;&lt;span class="esk-paren"&gt;(&lt;/span&gt;&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function-name"&gt;html&lt;/span&gt; &lt;span class="esk-paren"&gt;(&lt;/span&gt;html-resource 
            &lt;span class="esk-paren"&gt;(&lt;/span&gt;io/file &lt;span class="string"&gt;"/source/_postlist.html"&lt;/span&gt;&lt;span class="esk-paren"&gt;)))&lt;/span&gt;
&lt;span class="comment-delimiter"&gt;;; &lt;/span&gt;&lt;span class="comment"&gt;=&amp;gt; ({:tag :html, :attrs nil, :content ({:tag :body, :attrs ...
&lt;/span&gt;  
&lt;span class="comment-delimiter"&gt;;; &lt;/span&gt;&lt;span class="comment"&gt;back to textual html again
&lt;/span&gt;&lt;span class="esk-paren"&gt;(&lt;/span&gt;emit* html&lt;span class="esk-paren"&gt;)&lt;/span&gt;
&lt;span class="comment-delimiter"&gt;;; &lt;/span&gt;&lt;span class="comment"&gt;=&amp;gt; ("&amp;lt;" "html" "&amp;gt;" "&amp;lt;" "body" "&amp;gt;" "&amp;lt;" "div" " " "id" "=\"" ...
&lt;/span&gt;
&lt;span class="comment-delimiter"&gt;;; &lt;/span&gt;&lt;span class="comment"&gt;back to a string
&lt;/span&gt;&lt;span class="esk-paren"&gt;(&lt;/span&gt;&lt;span class="builtin"&gt;apply&lt;/span&gt; str &lt;span class="esk-paren"&gt;(&lt;/span&gt;emit* html&lt;span class="esk-paren"&gt;))&lt;/span&gt;
&lt;span class="comment-delimiter"&gt;;; &lt;/span&gt;&lt;span class="comment"&gt;=&amp;gt; "&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;div id=\"home.....
&lt;/span&gt;
&lt;span class="comment-delimiter"&gt;;; &lt;/span&gt;&lt;span class="comment"&gt;select a seq of nodes from html with the css-like selector
&lt;/span&gt;&lt;span class="esk-paren"&gt;(&lt;/span&gt;&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function-name"&gt;date-node&lt;/span&gt; &lt;span class="esk-paren"&gt;(&lt;/span&gt;&lt;span class="type"&gt;select&lt;/span&gt; html [&lt;span class="builtin"&gt;:div.date&lt;/span&gt;]&lt;span class="esk-paren"&gt;))&lt;/span&gt;
&lt;span class="comment-delimiter"&gt;;; &lt;/span&gt;&lt;span class="comment"&gt;=&amp;gt; ({:tag :div, :attrs {:class "date"}, :content ("YYYY/MM/DD")})
&lt;/span&gt;
&lt;span class="comment-delimiter"&gt;;; &lt;/span&gt;&lt;span class="comment"&gt;tranform applies a transformation to a node
&lt;/span&gt;&lt;span class="esk-paren"&gt;(&lt;/span&gt;transform date-node
           [&lt;span class="builtin"&gt;:div.date&lt;/span&gt;]
           &lt;span class="esk-paren"&gt;(&lt;/span&gt;&lt;span class="builtin"&gt;fn&lt;/span&gt; [match]
             &lt;span class="esk-paren"&gt;(&lt;/span&gt;&lt;span class="builtin"&gt;assoc&lt;/span&gt; match &lt;span class="builtin"&gt;:content&lt;/span&gt; &lt;span class="string"&gt;"2012/03/15"&lt;/span&gt;&lt;span class="esk-paren"&gt;)))&lt;/span&gt;
&lt;span class="comment-delimiter"&gt;;; &lt;/span&gt;&lt;span class="comment"&gt;=&amp;gt; ({:tag :div, :attrs {:class "date"}, :content "2012/03/15"})
&lt;/span&gt;  
&lt;span class="comment-delimiter"&gt;;; &lt;/span&gt;&lt;span class="comment"&gt;the results of a transformation may also be a seq of nodes
&lt;/span&gt;&lt;span class="esk-paren"&gt;(&lt;/span&gt;transform date-node
           [&lt;span class="builtin"&gt;:div.date&lt;/span&gt;]
           &lt;span class="esk-paren"&gt;(&lt;/span&gt;&lt;span class="builtin"&gt;fn&lt;/span&gt; [match-node]
             [{&lt;span class="builtin"&gt;:tag&lt;/span&gt; &lt;span class="string"&gt;"hr"&lt;/span&gt; &lt;span class="builtin"&gt;:attrs&lt;/span&gt; nil &lt;span class="builtin"&gt;:content&lt;/span&gt; []}
              {&lt;span class="builtin"&gt;:tag&lt;/span&gt; &lt;span class="string"&gt;"p"&lt;/span&gt; &lt;span class="builtin"&gt;:attrs&lt;/span&gt; nil &lt;span class="builtin"&gt;:content&lt;/span&gt; &lt;span class="string"&gt;"new structure"&lt;/span&gt;}]&lt;span class="esk-paren"&gt;))&lt;/span&gt;
&lt;span class="comment-delimiter"&gt;;; &lt;/span&gt;&lt;span class="comment"&gt;=&amp;gt;
  ({:tag "hr", :attrs nil, :content []} 
   {:tag "p", :content "new structure", :attrs nil})
&lt;/span&gt;  &lt;/pre&gt;
&lt;p&gt;This code is also in clj-static-blog/src/clj_static_blog/core.clj.&lt;/p&gt;





&lt;/body&gt;&lt;/html&gt;</content>
 </entry>

</feed>